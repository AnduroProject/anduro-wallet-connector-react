"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/anduro-wallet-connector";
exports.ids = ["vendor-chunks/anduro-wallet-connector"];
exports.modules = {

/***/ "(ssr)/./node_modules/anduro-wallet-connector/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/anduro-wallet-connector/dist/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = function(target, all) {\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = function(to, from, except, desc) {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            var _loop = function() {\n                var key = _step.value;\n                if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n                    get: function() {\n                        return from[key];\n                    },\n                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n                });\n            };\n            for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    return to;\n};\nvar __toESM = function(mod, isNodeMode, target) {\n    return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod);\n};\nvar __toCommonJS = function(mod) {\n    return __copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n};\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    UseConnectorProvider: function() {\n        return UseConnectorProvider;\n    },\n    useConnector: function() {\n        return useConnector;\n    }\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/hooks/useConnector.tsx\nvar import_react = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// src/helpers/errorMessages.tsx\nvar FAIL_PROCESS = \"Can't process your request\";\nvar ERROR_MESSAGES = {\n    walletNotConnected: \"The wallet is not connected.\",\n    transactionTypeRequired: \"\".concat(FAIL_PROCESS, \", Transaction Type is required\"),\n    transactionTypeInvalid: \"\".concat(FAIL_PROCESS, \", Invalid transaction type\"),\n    amountRequired: \"\".concat(FAIL_PROCESS, \", Amount is required\"),\n    nameRequired: \"\".concat(FAIL_PROCESS, \", Name is required\"),\n    symbolRequired: \"\".concat(FAIL_PROCESS, \", Symbol is required\"),\n    imageUrlRequired: \"\".concat(FAIL_PROCESS, \", Image Url is required\"),\n    supplyRequired: \"\".concat(FAIL_PROCESS, \", Supply is required\"),\n    assetTypeRequired: \"\".concat(FAIL_PROCESS, \", Asset Type is required\"),\n    assetTypeInvalid: \"\".concat(FAIL_PROCESS, \", Invalid Asset Type\"),\n    assetIdRequired: \"\".concat(FAIL_PROCESS, \", Asset Id is required\"),\n    receiverAddressRequired: \"\".concat(FAIL_PROCESS, \", Receiver Address is required\")\n};\n// src/helpers/handleResponse.tsx\nvar handleErrorResponse = function() {\n    var error = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    return {\n        status: false,\n        result: null,\n        error: error\n    };\n};\nvar handleSuccessResponse = function() {\n    var result = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    return {\n        status: true,\n        result: result,\n        error: null\n    };\n};\n// src/helpers/handleWalletWindow.tsx\nvar openWalletWindow = function(url) {\n    var _window_top, _window_top1, _window_top2, _window_top3;\n    var inputWidth = 370;\n    var inputHeight = 550;\n    var viewportwidth = document.documentElement.clientWidth;\n    var tempW = (_window_top = window.top) === null || _window_top === void 0 ? void 0 : _window_top.outerWidth;\n    var tempH = (_window_top1 = window.top) === null || _window_top1 === void 0 ? void 0 : _window_top1.outerHeight;\n    var tempSY = (_window_top2 = window.top) === null || _window_top2 === void 0 ? void 0 : _window_top2.screenY;\n    var tempSX = (_window_top3 = window.top) === null || _window_top3 === void 0 ? void 0 : _window_top3.screenX;\n    var y = tempH / 2 + tempSY - inputHeight / 2;\n    var x = tempW / 2 + tempSX - inputWidth / 2;\n    if (viewportwidth > 800) {\n        x = viewportwidth - 300;\n        y = 0;\n    }\n    return window.open(url, \"_blank\", \"toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=\".concat(inputWidth, \", height=\").concat(inputHeight, \", right=0, top=\").concat(y, \", left=\").concat(x));\n};\n// src/hooks/useConnector.tsx\nvar import_jsx_runtime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar useConnector = import_react.default.createContext(null);\nvar resolvePromise = null;\nvar UseConnectorProvider = function(props) {\n    var _ref = _sliced_to_array((0, import_react.useState)(null), 2), childWindow = _ref[0], setChildWindow = _ref[1];\n    var _ref1 = _sliced_to_array((0, import_react.useState)(), 2), requestType = _ref1[0], setRequestType = _ref1[1];\n    var _ref2 = _sliced_to_array((0, import_react.useState)({}), 2), transactionData = _ref2[0], setTransactionData = _ref2[1];\n    var _import_react_default_useState = _sliced_to_array(import_react.default.useState(null), 2), requestData = _import_react_default_useState[0], setRequestData = _import_react_default_useState[1];\n    var _import_react_default_useState1 = _sliced_to_array(import_react.default.useState({}), 2), createAssetData = _import_react_default_useState1[0], setCreateAssetData = _import_react_default_useState1[1];\n    var _import_react_default_useState2 = _sliced_to_array(import_react.default.useState({}), 2), transferAssetData = _import_react_default_useState2[0], setTransferAssetData = _import_react_default_useState2[1];\n    var _import_react_default_useState3 = _sliced_to_array(import_react.default.useState({\n        chainId: null,\n        networkType: \"\"\n    }), 2), networkState = _import_react_default_useState3[0], setNetworkState = _import_react_default_useState3[1];\n    var _import_react_default_useState4 = _sliced_to_array(import_react.default.useState({\n        accountPublicKey: \"\",\n        connectionState: \"disconnected\"\n    }), 2), walletState = _import_react_default_useState4[0], setWalletState = _import_react_default_useState4[1];\n    var _ref3 = _sliced_to_array((0, import_react.useState)(props.walletURL), 2), walletURL = _ref3[0], setWalletURL = _ref3[1];\n    (0, import_react.useEffect)(function() {\n        if (networkState.chainId === null && requestType !== \"disconnect\") {\n            var url = \"\".concat(walletURL, \"?requestType=\", \"networkinfo\" /* networkinfo */ );\n            var targetWindow = openWalletWindow(url);\n            setChildWindow(targetWindow);\n            setRequestType(\"networkinfo\" /* networkinfo */ );\n        }\n    }, [\n        networkState\n    ]);\n    (0, import_react.useEffect)(function() {\n        if (childWindow != null) {\n            window.addEventListener(\"message\", handleMessage);\n            return function() {\n                window.removeEventListener(\"message\", handleMessage);\n            };\n        }\n    }, [\n        childWindow\n    ]);\n    var handleMessage = function(event) {\n        if (!event.data.type) return false;\n        if (event.data.type == \"webpackOk\") return false;\n        if (event.data.type === \"wallet-loaded\" /* walletLoaded */ ) return handlewalletLoadedMessage();\n        if (childWindow) childWindow.close();\n        if (!event.data.status) return handleErrorResponse(event.data.error ? event.data.error : event.data);\n        switch(event.data.type){\n            case \"connection-response\" /* connectionResponse */ :\n                updateNetworkInformation(event.data.result);\n                updateWalletInformation(\"connected\", event.data.result.accountPublicKey);\n                resolvePromise(handleSuccessResponse(event.data));\n                break;\n            case \"account-not-created\" /* accountNotCreated */ :\n                if (resolvePromise) resolvePromise(handleErrorResponse(event.data));\n                break;\n            case \"networkinfo-response\" /* networkinfoResponse */ :\n                updateNetworkInformation(event.data.result);\n                updateWalletInformation(\"conneted\", event.data.result.accountPublicKey);\n                break;\n            case \"disconnect-response\" /* disconnectResponse */ :\n                updateNetworkInformation({\n                    chainId: null,\n                    networkType: \"\"\n                });\n                updateWalletInformation(\"disconnected\", \"\");\n                break;\n            default:\n                if (resolvePromise) resolvePromise(handleSuccessResponse(event.data));\n                break;\n        }\n    };\n    var handlewalletLoadedMessage = function() {\n        if (requestType === \"connect\" /* connect */  || requestType === \"disconnect\" /* disconnected */ ) {\n            sendMessageToChildWindow({\n                requestType: requestType,\n                siteurl: window.location.origin,\n                chainId: requestData ? requestData.chainId : 0\n            });\n        } else if (requestType === \"networkinfo\" /* networkinfo */ ) {\n            sendMessageToChildWindow({\n                requestType: requestType,\n                siteurl: window.location.origin\n            });\n        } else if (requestType === \"send\" /* send */ ) {\n            sendMessageToChildWindow({\n                requestType: requestType,\n                transactionType: transactionData.transactionType,\n                amount: transactionData.amount,\n                receiverAddress: transactionData.receiverAddress,\n                feerate: transactionData.feeRate,\n                chainId: networkState.chainId\n            });\n        } else if (requestType === \"create-asset\" /* createAsset */ ) {\n            var formValues = {\n                headline: createAssetData.name,\n                imageUrl: createAssetData.imageUrl,\n                supply: createAssetData.supply,\n                imagebase64Data: {\n                    data: \"\",\n                    type: \"\"\n                },\n                symbol: createAssetData.symbol\n            };\n            sendMessageToChildWindow({\n                requestType: requestType,\n                transactionType: createAssetData.transactionType,\n                formValues: formValues,\n                assetType: createAssetData.assetType,\n                properties: createAssetData.properties,\n                chainId: networkState.chainId,\n                supply: createAssetData.supply,\n                receiverAddress: createAssetData.receiverAddress,\n                assetId: createAssetData.assetId\n            });\n        } else if (requestType === \"transfer-asset\" /* transferAsset */ ) {\n            sendMessageToChildWindow({\n                requestType: requestType,\n                chainId: networkState.chainId,\n                supply: transferAssetData.supply,\n                receiverAddress: transferAssetData.receiverAddress,\n                assetId: transferAssetData.assetId\n            });\n        }\n    };\n    var sendMessageToChildWindow = function(data) {\n        childWindow.postMessage(data, \"*\");\n    };\n    var updateNetworkInformation = function(params) {\n        setNetworkState({\n            chainId: params.chainId,\n            networkType: params.networkType\n        });\n    };\n    var updateWalletInformation = function(connectionState, accountPublicKey) {\n        setWalletState({\n            accountPublicKey: accountPublicKey,\n            connectionState: connectionState\n        });\n    };\n    var connect = function() {\n        var _ref = _async_to_generator(function(params) {\n            return _ts_generator(this, function(_state) {\n                return [\n                    2,\n                    new Promise(function(resolve) {\n                        var url = \"\".concat(walletURL, \"?requestType=\", \"connect\" /* connect */ );\n                        var childWindow2 = openWalletWindow(url);\n                        setWalletURL(walletURL);\n                        setRequestType(\"connect\" /* connect */ );\n                        setChildWindow(childWindow2);\n                        setRequestData({\n                            chainId: params.chainId\n                        });\n                        updateWalletInformation(\"connecting\", \"\");\n                        resolvePromise = resolve;\n                    })\n                ];\n            });\n        });\n        return function connect(params) {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    var disconnect = function() {\n        return new Promise(function(resolve) {\n            var url = \"\".concat(walletURL, \"?requestType=\", \"disconnect\" /* disconnected */ );\n            var childWindow2 = openWalletWindow(url);\n            setRequestType(\"disconnect\" /* disconnected */ );\n            setChildWindow(childWindow2);\n            updateWalletInformation(\"disconnecting\", \"\");\n            resolvePromise = resolve;\n        });\n    };\n    var send = function(params) {\n        if (!params.transactionType) return handleErrorResponse(ERROR_MESSAGES.transactionTypeRequired);\n        if (!params.amount) return handleErrorResponse(ERROR_MESSAGES.amountRequired);\n        if (!validateSendTransactionType(params.transactionType)) return handleErrorResponse(ERROR_MESSAGES.transactionTypeInvalid);\n        return new Promise(function(resolve) {\n            if (checkWalletConnection(resolve, \"\") && params.transactionType) {\n                var url = \"\".concat(walletURL, \"?requestType=\", \"send\" /* send */ );\n                var childWindow2 = openWalletWindow(url);\n                setRequestType(\"send\" /* send */ );\n                setChildWindow(childWindow2);\n                setTransactionData(params);\n                resolvePromise = resolve;\n            }\n        });\n    };\n    var checkWalletConnection = function(resolve, transactionType) {\n        var status = true;\n        var error = null;\n        if (networkState.chainId === null || networkState.networkType === \"\") {\n            status = false;\n            error = ERROR_MESSAGES.walletNotConnected;\n        } else if (transactionType && networkState.networkType === \"bitcoin\" /* bitcoin */ ) {\n            status = false;\n            error = ERROR_MESSAGES.transactionTypeInvalid;\n        }\n        if (!status) {\n            resolve({\n                status: status,\n                result: null,\n                error: error\n            });\n        }\n        return status;\n    };\n    var validateSendTransactionType = function(transactionType) {\n        var status = false;\n        if (transactionType === \"normal\" /* normal */ ) {\n            status = true;\n        } else if (transactionType === \"pegin\" /* pegin */ ) {\n            status = networkState.networkType === \"bitcoin\" /* bitcoin */ ;\n        } else if (transactionType === \"pegout\" /* pegout */ ) {\n            status = networkState.networkType === \"sidechain\" /* sidechain */ ;\n        }\n        return status;\n    };\n    var createasset = function(params) {\n        if (!params.transactionType) return handleErrorResponse(ERROR_MESSAGES.transactionTypeRequired);\n        if (!params.name) return handleErrorResponse(ERROR_MESSAGES.nameRequired);\n        if (!params.symbol) return handleErrorResponse(ERROR_MESSAGES.symbolRequired);\n        if (!params.imageUrl) return handleErrorResponse(ERROR_MESSAGES.imageUrlRequired);\n        if (!params.supply) return handleErrorResponse(ERROR_MESSAGES.supplyRequired);\n        if (params.assetType === void 0 || params.assetType === null) return handleErrorResponse(ERROR_MESSAGES.assetTypeRequired);\n        return new Promise(function(resolve) {\n            if (params.transactionType && checkWalletConnection(resolve, params.transactionType)) {\n                var url = \"\".concat(walletURL, \"?requestType=\", \"create-asset\" /* createAsset */ );\n                var childWindow2 = openWalletWindow(url);\n                setRequestType(\"create-asset\" /* createAsset */ );\n                setChildWindow(childWindow2);\n                setCreateAssetData(params);\n                resolvePromise = resolve;\n            }\n        });\n    };\n    var transferasset = function(params) {\n        if (!params.assetId) return handleErrorResponse(ERROR_MESSAGES.assetIdRequired);\n        if (!params.receiverAddress) return handleErrorResponse(ERROR_MESSAGES.receiverAddressRequired);\n        if (!params.supply) return handleErrorResponse(ERROR_MESSAGES.supplyRequired);\n        return new Promise(function(resolve) {\n            if (checkWalletConnection(resolve, \"transfer\")) {\n                var url = \"\".concat(walletURL, \"?requestType=\", \"transfer-asset\" /* transferAsset */ );\n                var childWindow2 = openWalletWindow(url);\n                setRequestType(\"transfer-asset\" /* transferAsset */ );\n                setChildWindow(childWindow2);\n                setTransferAssetData(params);\n                resolvePromise = resolve;\n            }\n        });\n    };\n    var children = props.children;\n    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(useConnector.Provider, {\n        value: {\n            walletState: walletState,\n            networkState: networkState,\n            connect: connect,\n            disconnect: disconnect,\n            send: send,\n            createasset: createasset,\n            transferasset: transferasset\n        },\n        children: children\n    });\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW5kdXJvLXdhbGxldC1jb25uZWN0b3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsbUZBQW1GLGdFQUFnRTtBQUNuSixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsd0dBQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxnSUFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLDJGQUEyRjtBQUMzRiwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU0sQ0FHTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5kdXJvLXdhbGxldC1jb25uZWN0b3ItcmVhY3QtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9hbmR1cm8td2FsbGV0LWNvbm5lY3Rvci9kaXN0L2luZGV4LmpzP2U2MjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfYXJyYXlfbGlrZV90b19hcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlfd2l0aF9ob2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY190b19nZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX3MsIF9lO1xuICAgIHRyeSB7XG4gICAgICAgIGZvcihfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSl7XG4gICAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kID0gdHJ1ZTtcbiAgICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5e1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xufVxuZnVuY3Rpb24gX25vbl9pdGVyYWJsZV9yZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRfdG9fYXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheV93aXRoX2hvbGVzKGFycikgfHwgX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KGFyciwgaSkgfHwgX25vbl9pdGVyYWJsZV9yZXN0KCk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfdHNfZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgZiwgeSwgdCwgZywgXyA9IHtcbiAgICAgICAgbGFiZWw6IDAsXG4gICAgICAgIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIH0sXG4gICAgICAgIHRyeXM6IFtdLFxuICAgICAgICBvcHM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZyA9IHtcbiAgICAgICAgbmV4dDogdmVyYigwKSxcbiAgICAgICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgICAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gICAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlKF8pdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbXG4gICAgICAgICAgICAgICAgb3BbMF0gJiAyLFxuICAgICAgICAgICAgICAgIHQudmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzd2l0Y2gob3BbMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG59XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gZnVuY3Rpb24odGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKV9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSBmdW5jdGlvbih0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSB7XG4gICAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpIF9fZGVmUHJvcCh0bywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX19nZXRPd25Qcm9wTmFtZXMoZnJvbSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKV9sb29wKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gZnVuY3Rpb24obW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAgIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gICAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gICAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICAgIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwge1xuICAgICAgICB2YWx1ZTogbW9kLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSkgOiB0YXJnZXQsIG1vZCk7XG59O1xudmFyIF9fdG9Db21tb25KUyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgIHJldHVybiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSksIG1vZCk7XG59O1xuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gICAgVXNlQ29ubmVjdG9yUHJvdmlkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gVXNlQ29ubmVjdG9yUHJvdmlkZXI7XG4gICAgfSxcbiAgICB1c2VDb25uZWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlQ29ubmVjdG9yO1xuICAgIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuLy8gc3JjL2hvb2tzL3VzZUNvbm5lY3Rvci50c3hcbnZhciBpbXBvcnRfcmVhY3QgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG4vLyBzcmMvaGVscGVycy9lcnJvck1lc3NhZ2VzLnRzeFxudmFyIEZBSUxfUFJPQ0VTUyA9IFwiQ2FuJ3QgcHJvY2VzcyB5b3VyIHJlcXVlc3RcIjtcbnZhciBFUlJPUl9NRVNTQUdFUyA9IHtcbiAgICB3YWxsZXROb3RDb25uZWN0ZWQ6IFwiVGhlIHdhbGxldCBpcyBub3QgY29ubmVjdGVkLlwiLFxuICAgIHRyYW5zYWN0aW9uVHlwZVJlcXVpcmVkOiBcIlwiLmNvbmNhdChGQUlMX1BST0NFU1MsIFwiLCBUcmFuc2FjdGlvbiBUeXBlIGlzIHJlcXVpcmVkXCIpLFxuICAgIHRyYW5zYWN0aW9uVHlwZUludmFsaWQ6IFwiXCIuY29uY2F0KEZBSUxfUFJPQ0VTUywgXCIsIEludmFsaWQgdHJhbnNhY3Rpb24gdHlwZVwiKSxcbiAgICBhbW91bnRSZXF1aXJlZDogXCJcIi5jb25jYXQoRkFJTF9QUk9DRVNTLCBcIiwgQW1vdW50IGlzIHJlcXVpcmVkXCIpLFxuICAgIG5hbWVSZXF1aXJlZDogXCJcIi5jb25jYXQoRkFJTF9QUk9DRVNTLCBcIiwgTmFtZSBpcyByZXF1aXJlZFwiKSxcbiAgICBzeW1ib2xSZXF1aXJlZDogXCJcIi5jb25jYXQoRkFJTF9QUk9DRVNTLCBcIiwgU3ltYm9sIGlzIHJlcXVpcmVkXCIpLFxuICAgIGltYWdlVXJsUmVxdWlyZWQ6IFwiXCIuY29uY2F0KEZBSUxfUFJPQ0VTUywgXCIsIEltYWdlIFVybCBpcyByZXF1aXJlZFwiKSxcbiAgICBzdXBwbHlSZXF1aXJlZDogXCJcIi5jb25jYXQoRkFJTF9QUk9DRVNTLCBcIiwgU3VwcGx5IGlzIHJlcXVpcmVkXCIpLFxuICAgIGFzc2V0VHlwZVJlcXVpcmVkOiBcIlwiLmNvbmNhdChGQUlMX1BST0NFU1MsIFwiLCBBc3NldCBUeXBlIGlzIHJlcXVpcmVkXCIpLFxuICAgIGFzc2V0VHlwZUludmFsaWQ6IFwiXCIuY29uY2F0KEZBSUxfUFJPQ0VTUywgXCIsIEludmFsaWQgQXNzZXQgVHlwZVwiKSxcbiAgICBhc3NldElkUmVxdWlyZWQ6IFwiXCIuY29uY2F0KEZBSUxfUFJPQ0VTUywgXCIsIEFzc2V0IElkIGlzIHJlcXVpcmVkXCIpLFxuICAgIHJlY2VpdmVyQWRkcmVzc1JlcXVpcmVkOiBcIlwiLmNvbmNhdChGQUlMX1BST0NFU1MsIFwiLCBSZWNlaXZlciBBZGRyZXNzIGlzIHJlcXVpcmVkXCIpXG59O1xuLy8gc3JjL2hlbHBlcnMvaGFuZGxlUmVzcG9uc2UudHN4XG52YXIgaGFuZGxlRXJyb3JSZXNwb25zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlcnJvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IGZhbHNlLFxuICAgICAgICByZXN1bHQ6IG51bGwsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG59O1xudmFyIGhhbmRsZVN1Y2Nlc3NSZXNwb25zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiB0cnVlLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xufTtcbi8vIHNyYy9oZWxwZXJzL2hhbmRsZVdhbGxldFdpbmRvdy50c3hcbnZhciBvcGVuV2FsbGV0V2luZG93ID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIF93aW5kb3dfdG9wLCBfd2luZG93X3RvcDEsIF93aW5kb3dfdG9wMiwgX3dpbmRvd190b3AzO1xuICAgIHZhciBpbnB1dFdpZHRoID0gMzcwO1xuICAgIHZhciBpbnB1dEhlaWdodCA9IDU1MDtcbiAgICB2YXIgdmlld3BvcnR3aWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB2YXIgdGVtcFcgPSAoX3dpbmRvd190b3AgPSB3aW5kb3cudG9wKSA9PT0gbnVsbCB8fCBfd2luZG93X3RvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd190b3Aub3V0ZXJXaWR0aDtcbiAgICB2YXIgdGVtcEggPSAoX3dpbmRvd190b3AxID0gd2luZG93LnRvcCkgPT09IG51bGwgfHwgX3dpbmRvd190b3AxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X3RvcDEub3V0ZXJIZWlnaHQ7XG4gICAgdmFyIHRlbXBTWSA9IChfd2luZG93X3RvcDIgPSB3aW5kb3cudG9wKSA9PT0gbnVsbCB8fCBfd2luZG93X3RvcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3dfdG9wMi5zY3JlZW5ZO1xuICAgIHZhciB0ZW1wU1ggPSAoX3dpbmRvd190b3AzID0gd2luZG93LnRvcCkgPT09IG51bGwgfHwgX3dpbmRvd190b3AzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X3RvcDMuc2NyZWVuWDtcbiAgICB2YXIgeSA9IHRlbXBIIC8gMiArIHRlbXBTWSAtIGlucHV0SGVpZ2h0IC8gMjtcbiAgICB2YXIgeCA9IHRlbXBXIC8gMiArIHRlbXBTWCAtIGlucHV0V2lkdGggLyAyO1xuICAgIGlmICh2aWV3cG9ydHdpZHRoID4gODAwKSB7XG4gICAgICAgIHggPSB2aWV3cG9ydHdpZHRoIC0gMzAwO1xuICAgICAgICB5ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5vcGVuKHVybCwgXCJfYmxhbmtcIiwgXCJ0b29sYmFyPW5vLCBsb2NhdGlvbj1ubywgZGlyZWN0b3JpZXM9bm8sIHN0YXR1cz1ubywgbWVudWJhcj1ubywgc2Nyb2xsYmFycz1ubywgcmVzaXphYmxlPW5vLCBjb3B5aGlzdG9yeT1ubywgd2lkdGg9XCIuY29uY2F0KGlucHV0V2lkdGgsIFwiLCBoZWlnaHQ9XCIpLmNvbmNhdChpbnB1dEhlaWdodCwgXCIsIHJpZ2h0PTAsIHRvcD1cIikuY29uY2F0KHksIFwiLCBsZWZ0PVwiKS5jb25jYXQoeCkpO1xufTtcbi8vIHNyYy9ob29rcy91c2VDb25uZWN0b3IudHN4XG52YXIgaW1wb3J0X2pzeF9ydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIHVzZUNvbm5lY3RvciA9IGltcG9ydF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgcmVzb2x2ZVByb21pc2UgPSBudWxsO1xudmFyIFVzZUNvbm5lY3RvclByb3ZpZGVyID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICB2YXIgX3JlZiA9IF9zbGljZWRfdG9fYXJyYXkoKDAsIGltcG9ydF9yZWFjdC51c2VTdGF0ZSkobnVsbCksIDIpLCBjaGlsZFdpbmRvdyA9IF9yZWZbMF0sIHNldENoaWxkV2luZG93ID0gX3JlZlsxXTtcbiAgICB2YXIgX3JlZjEgPSBfc2xpY2VkX3RvX2FycmF5KCgwLCBpbXBvcnRfcmVhY3QudXNlU3RhdGUpKCksIDIpLCByZXF1ZXN0VHlwZSA9IF9yZWYxWzBdLCBzZXRSZXF1ZXN0VHlwZSA9IF9yZWYxWzFdO1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRfdG9fYXJyYXkoKDAsIGltcG9ydF9yZWFjdC51c2VTdGF0ZSkoe30pLCAyKSwgdHJhbnNhY3Rpb25EYXRhID0gX3JlZjJbMF0sIHNldFRyYW5zYWN0aW9uRGF0YSA9IF9yZWYyWzFdO1xuICAgIHZhciBfaW1wb3J0X3JlYWN0X2RlZmF1bHRfdXNlU3RhdGUgPSBfc2xpY2VkX3RvX2FycmF5KGltcG9ydF9yZWFjdC5kZWZhdWx0LnVzZVN0YXRlKG51bGwpLCAyKSwgcmVxdWVzdERhdGEgPSBfaW1wb3J0X3JlYWN0X2RlZmF1bHRfdXNlU3RhdGVbMF0sIHNldFJlcXVlc3REYXRhID0gX2ltcG9ydF9yZWFjdF9kZWZhdWx0X3VzZVN0YXRlWzFdO1xuICAgIHZhciBfaW1wb3J0X3JlYWN0X2RlZmF1bHRfdXNlU3RhdGUxID0gX3NsaWNlZF90b19hcnJheShpbXBvcnRfcmVhY3QuZGVmYXVsdC51c2VTdGF0ZSh7fSksIDIpLCBjcmVhdGVBc3NldERhdGEgPSBfaW1wb3J0X3JlYWN0X2RlZmF1bHRfdXNlU3RhdGUxWzBdLCBzZXRDcmVhdGVBc3NldERhdGEgPSBfaW1wb3J0X3JlYWN0X2RlZmF1bHRfdXNlU3RhdGUxWzFdO1xuICAgIHZhciBfaW1wb3J0X3JlYWN0X2RlZmF1bHRfdXNlU3RhdGUyID0gX3NsaWNlZF90b19hcnJheShpbXBvcnRfcmVhY3QuZGVmYXVsdC51c2VTdGF0ZSh7fSksIDIpLCB0cmFuc2ZlckFzc2V0RGF0YSA9IF9pbXBvcnRfcmVhY3RfZGVmYXVsdF91c2VTdGF0ZTJbMF0sIHNldFRyYW5zZmVyQXNzZXREYXRhID0gX2ltcG9ydF9yZWFjdF9kZWZhdWx0X3VzZVN0YXRlMlsxXTtcbiAgICB2YXIgX2ltcG9ydF9yZWFjdF9kZWZhdWx0X3VzZVN0YXRlMyA9IF9zbGljZWRfdG9fYXJyYXkoaW1wb3J0X3JlYWN0LmRlZmF1bHQudXNlU3RhdGUoe1xuICAgICAgICBjaGFpbklkOiBudWxsLFxuICAgICAgICBuZXR3b3JrVHlwZTogXCJcIlxuICAgIH0pLCAyKSwgbmV0d29ya1N0YXRlID0gX2ltcG9ydF9yZWFjdF9kZWZhdWx0X3VzZVN0YXRlM1swXSwgc2V0TmV0d29ya1N0YXRlID0gX2ltcG9ydF9yZWFjdF9kZWZhdWx0X3VzZVN0YXRlM1sxXTtcbiAgICB2YXIgX2ltcG9ydF9yZWFjdF9kZWZhdWx0X3VzZVN0YXRlNCA9IF9zbGljZWRfdG9fYXJyYXkoaW1wb3J0X3JlYWN0LmRlZmF1bHQudXNlU3RhdGUoe1xuICAgICAgICBhY2NvdW50UHVibGljS2V5OiBcIlwiLFxuICAgICAgICBjb25uZWN0aW9uU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICB9KSwgMiksIHdhbGxldFN0YXRlID0gX2ltcG9ydF9yZWFjdF9kZWZhdWx0X3VzZVN0YXRlNFswXSwgc2V0V2FsbGV0U3RhdGUgPSBfaW1wb3J0X3JlYWN0X2RlZmF1bHRfdXNlU3RhdGU0WzFdO1xuICAgIHZhciBfcmVmMyA9IF9zbGljZWRfdG9fYXJyYXkoKDAsIGltcG9ydF9yZWFjdC51c2VTdGF0ZSkocHJvcHMud2FsbGV0VVJMKSwgMiksIHdhbGxldFVSTCA9IF9yZWYzWzBdLCBzZXRXYWxsZXRVUkwgPSBfcmVmM1sxXTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0LnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChuZXR3b3JrU3RhdGUuY2hhaW5JZCA9PT0gbnVsbCAmJiByZXF1ZXN0VHlwZSAhPT0gXCJkaXNjb25uZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdCh3YWxsZXRVUkwsIFwiP3JlcXVlc3RUeXBlPVwiLCBcIm5ldHdvcmtpbmZvXCIgLyogbmV0d29ya2luZm8gKi8gKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRXaW5kb3cgPSBvcGVuV2FsbGV0V2luZG93KHVybCk7XG4gICAgICAgICAgICBzZXRDaGlsZFdpbmRvdyh0YXJnZXRXaW5kb3cpO1xuICAgICAgICAgICAgc2V0UmVxdWVzdFR5cGUoXCJuZXR3b3JraW5mb1wiIC8qIG5ldHdvcmtpbmZvICovICk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG5ldHdvcmtTdGF0ZVxuICAgIF0pO1xuICAgICgwLCBpbXBvcnRfcmVhY3QudXNlRWZmZWN0KShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNoaWxkV2luZG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBjaGlsZFdpbmRvd1xuICAgIF0pO1xuICAgIHZhciBoYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudC5kYXRhLnR5cGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcIndlYnBhY2tPa1wiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09IFwid2FsbGV0LWxvYWRlZFwiIC8qIHdhbGxldExvYWRlZCAqLyApIHJldHVybiBoYW5kbGV3YWxsZXRMb2FkZWRNZXNzYWdlKCk7XG4gICAgICAgIGlmIChjaGlsZFdpbmRvdykgY2hpbGRXaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgaWYgKCFldmVudC5kYXRhLnN0YXR1cykgcmV0dXJuIGhhbmRsZUVycm9yUmVzcG9uc2UoZXZlbnQuZGF0YS5lcnJvciA/IGV2ZW50LmRhdGEuZXJyb3IgOiBldmVudC5kYXRhKTtcbiAgICAgICAgc3dpdGNoKGV2ZW50LmRhdGEudHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiY29ubmVjdGlvbi1yZXNwb25zZVwiIC8qIGNvbm5lY3Rpb25SZXNwb25zZSAqLyA6XG4gICAgICAgICAgICAgICAgdXBkYXRlTmV0d29ya0luZm9ybWF0aW9uKGV2ZW50LmRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVXYWxsZXRJbmZvcm1hdGlvbihcImNvbm5lY3RlZFwiLCBldmVudC5kYXRhLnJlc3VsdC5hY2NvdW50UHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShoYW5kbGVTdWNjZXNzUmVzcG9uc2UoZXZlbnQuZGF0YSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFjY291bnQtbm90LWNyZWF0ZWRcIiAvKiBhY2NvdW50Tm90Q3JlYXRlZCAqLyA6XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVQcm9taXNlKSByZXNvbHZlUHJvbWlzZShoYW5kbGVFcnJvclJlc3BvbnNlKGV2ZW50LmRhdGEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JraW5mby1yZXNwb25zZVwiIC8qIG5ldHdvcmtpbmZvUmVzcG9uc2UgKi8gOlxuICAgICAgICAgICAgICAgIHVwZGF0ZU5ldHdvcmtJbmZvcm1hdGlvbihldmVudC5kYXRhLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlV2FsbGV0SW5mb3JtYXRpb24oXCJjb25uZXRlZFwiLCBldmVudC5kYXRhLnJlc3VsdC5hY2NvdW50UHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkaXNjb25uZWN0LXJlc3BvbnNlXCIgLyogZGlzY29ubmVjdFJlc3BvbnNlICovIDpcbiAgICAgICAgICAgICAgICB1cGRhdGVOZXR3b3JrSW5mb3JtYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrVHlwZTogXCJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVdhbGxldEluZm9ybWF0aW9uKFwiZGlzY29ubmVjdGVkXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZVByb21pc2UpIHJlc29sdmVQcm9taXNlKGhhbmRsZVN1Y2Nlc3NSZXNwb25zZShldmVudC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGV3YWxsZXRMb2FkZWRNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0VHlwZSA9PT0gXCJjb25uZWN0XCIgLyogY29ubmVjdCAqLyAgfHwgcmVxdWVzdFR5cGUgPT09IFwiZGlzY29ubmVjdFwiIC8qIGRpc2Nvbm5lY3RlZCAqLyApIHtcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlVG9DaGlsZFdpbmRvdyh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFR5cGU6IHJlcXVlc3RUeXBlLFxuICAgICAgICAgICAgICAgIHNpdGV1cmw6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogcmVxdWVzdERhdGEgPyByZXF1ZXN0RGF0YS5jaGFpbklkIDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdFR5cGUgPT09IFwibmV0d29ya2luZm9cIiAvKiBuZXR3b3JraW5mbyAqLyApIHtcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlVG9DaGlsZFdpbmRvdyh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFR5cGU6IHJlcXVlc3RUeXBlLFxuICAgICAgICAgICAgICAgIHNpdGV1cmw6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3RUeXBlID09PSBcInNlbmRcIiAvKiBzZW5kICovICkge1xuICAgICAgICAgICAgc2VuZE1lc3NhZ2VUb0NoaWxkV2luZG93KHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcmVxdWVzdFR5cGUsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25UeXBlOiB0cmFuc2FjdGlvbkRhdGEudHJhbnNhY3Rpb25UeXBlLFxuICAgICAgICAgICAgICAgIGFtb3VudDogdHJhbnNhY3Rpb25EYXRhLmFtb3VudCxcbiAgICAgICAgICAgICAgICByZWNlaXZlckFkZHJlc3M6IHRyYW5zYWN0aW9uRGF0YS5yZWNlaXZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZmVlcmF0ZTogdHJhbnNhY3Rpb25EYXRhLmZlZVJhdGUsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogbmV0d29ya1N0YXRlLmNoYWluSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3RUeXBlID09PSBcImNyZWF0ZS1hc3NldFwiIC8qIGNyZWF0ZUFzc2V0ICovICkge1xuICAgICAgICAgICAgdmFyIGZvcm1WYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGxpbmU6IGNyZWF0ZUFzc2V0RGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgIGltYWdlVXJsOiBjcmVhdGVBc3NldERhdGEuaW1hZ2VVcmwsXG4gICAgICAgICAgICAgICAgc3VwcGx5OiBjcmVhdGVBc3NldERhdGEuc3VwcGx5LFxuICAgICAgICAgICAgICAgIGltYWdlYmFzZTY0RGF0YToge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IGNyZWF0ZUFzc2V0RGF0YS5zeW1ib2xcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZW5kTWVzc2FnZVRvQ2hpbGRXaW5kb3coe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiByZXF1ZXN0VHlwZSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblR5cGU6IGNyZWF0ZUFzc2V0RGF0YS50cmFuc2FjdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgZm9ybVZhbHVlczogZm9ybVZhbHVlcyxcbiAgICAgICAgICAgICAgICBhc3NldFR5cGU6IGNyZWF0ZUFzc2V0RGF0YS5hc3NldFR5cGUsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogY3JlYXRlQXNzZXREYXRhLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogbmV0d29ya1N0YXRlLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgc3VwcGx5OiBjcmVhdGVBc3NldERhdGEuc3VwcGx5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVyQWRkcmVzczogY3JlYXRlQXNzZXREYXRhLnJlY2VpdmVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhc3NldElkOiBjcmVhdGVBc3NldERhdGEuYXNzZXRJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdFR5cGUgPT09IFwidHJhbnNmZXItYXNzZXRcIiAvKiB0cmFuc2ZlckFzc2V0ICovICkge1xuICAgICAgICAgICAgc2VuZE1lc3NhZ2VUb0NoaWxkV2luZG93KHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcmVxdWVzdFR5cGUsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogbmV0d29ya1N0YXRlLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgc3VwcGx5OiB0cmFuc2ZlckFzc2V0RGF0YS5zdXBwbHksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJBZGRyZXNzOiB0cmFuc2ZlckFzc2V0RGF0YS5yZWNlaXZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYXNzZXRJZDogdHJhbnNmZXJBc3NldERhdGEuYXNzZXRJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzZW5kTWVzc2FnZVRvQ2hpbGRXaW5kb3cgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGNoaWxkV2luZG93LnBvc3RNZXNzYWdlKGRhdGEsIFwiKlwiKTtcbiAgICB9O1xuICAgIHZhciB1cGRhdGVOZXR3b3JrSW5mb3JtYXRpb24gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgc2V0TmV0d29ya1N0YXRlKHtcbiAgICAgICAgICAgIGNoYWluSWQ6IHBhcmFtcy5jaGFpbklkLFxuICAgICAgICAgICAgbmV0d29ya1R5cGU6IHBhcmFtcy5uZXR3b3JrVHlwZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciB1cGRhdGVXYWxsZXRJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25TdGF0ZSwgYWNjb3VudFB1YmxpY0tleSkge1xuICAgICAgICBzZXRXYWxsZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY2NvdW50UHVibGljS2V5OiBhY2NvdW50UHVibGljS2V5LFxuICAgICAgICAgICAgY29ubmVjdGlvblN0YXRlOiBjb25uZWN0aW9uU3RhdGVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQod2FsbGV0VVJMLCBcIj9yZXF1ZXN0VHlwZT1cIiwgXCJjb25uZWN0XCIgLyogY29ubmVjdCAqLyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkV2luZG93MiA9IG9wZW5XYWxsZXRXaW5kb3codXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFdhbGxldFVSTCh3YWxsZXRVUkwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVxdWVzdFR5cGUoXCJjb25uZWN0XCIgLyogY29ubmVjdCAqLyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q2hpbGRXaW5kb3coY2hpbGRXaW5kb3cyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlcXVlc3REYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBwYXJhbXMuY2hhaW5JZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVXYWxsZXRJbmZvcm1hdGlvbihcImNvbm5lY3RpbmdcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH0oKTtcbiAgICB2YXIgZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KHdhbGxldFVSTCwgXCI/cmVxdWVzdFR5cGU9XCIsIFwiZGlzY29ubmVjdFwiIC8qIGRpc2Nvbm5lY3RlZCAqLyApO1xuICAgICAgICAgICAgdmFyIGNoaWxkV2luZG93MiA9IG9wZW5XYWxsZXRXaW5kb3codXJsKTtcbiAgICAgICAgICAgIHNldFJlcXVlc3RUeXBlKFwiZGlzY29ubmVjdFwiIC8qIGRpc2Nvbm5lY3RlZCAqLyApO1xuICAgICAgICAgICAgc2V0Q2hpbGRXaW5kb3coY2hpbGRXaW5kb3cyKTtcbiAgICAgICAgICAgIHVwZGF0ZVdhbGxldEluZm9ybWF0aW9uKFwiZGlzY29ubmVjdGluZ1wiLCBcIlwiKTtcbiAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgc2VuZCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy50cmFuc2FjdGlvblR5cGUpIHJldHVybiBoYW5kbGVFcnJvclJlc3BvbnNlKEVSUk9SX01FU1NBR0VTLnRyYW5zYWN0aW9uVHlwZVJlcXVpcmVkKTtcbiAgICAgICAgaWYgKCFwYXJhbXMuYW1vdW50KSByZXR1cm4gaGFuZGxlRXJyb3JSZXNwb25zZShFUlJPUl9NRVNTQUdFUy5hbW91bnRSZXF1aXJlZCk7XG4gICAgICAgIGlmICghdmFsaWRhdGVTZW5kVHJhbnNhY3Rpb25UeXBlKHBhcmFtcy50cmFuc2FjdGlvblR5cGUpKSByZXR1cm4gaGFuZGxlRXJyb3JSZXNwb25zZShFUlJPUl9NRVNTQUdFUy50cmFuc2FjdGlvblR5cGVJbnZhbGlkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmIChjaGVja1dhbGxldENvbm5lY3Rpb24ocmVzb2x2ZSwgXCJcIikgJiYgcGFyYW1zLnRyYW5zYWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdCh3YWxsZXRVUkwsIFwiP3JlcXVlc3RUeXBlPVwiLCBcInNlbmRcIiAvKiBzZW5kICovICk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkV2luZG93MiA9IG9wZW5XYWxsZXRXaW5kb3codXJsKTtcbiAgICAgICAgICAgICAgICBzZXRSZXF1ZXN0VHlwZShcInNlbmRcIiAvKiBzZW5kICovICk7XG4gICAgICAgICAgICAgICAgc2V0Q2hpbGRXaW5kb3coY2hpbGRXaW5kb3cyKTtcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2FjdGlvbkRhdGEocGFyYW1zKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGNoZWNrV2FsbGV0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKHJlc29sdmUsIHRyYW5zYWN0aW9uVHlwZSkge1xuICAgICAgICB2YXIgc3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgICAgaWYgKG5ldHdvcmtTdGF0ZS5jaGFpbklkID09PSBudWxsIHx8IG5ldHdvcmtTdGF0ZS5uZXR3b3JrVHlwZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgc3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICBlcnJvciA9IEVSUk9SX01FU1NBR0VTLndhbGxldE5vdENvbm5lY3RlZDtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2FjdGlvblR5cGUgJiYgbmV0d29ya1N0YXRlLm5ldHdvcmtUeXBlID09PSBcImJpdGNvaW5cIiAvKiBiaXRjb2luICovICkge1xuICAgICAgICAgICAgc3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICBlcnJvciA9IEVSUk9SX01FU1NBR0VTLnRyYW5zYWN0aW9uVHlwZUludmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfTtcbiAgICB2YXIgdmFsaWRhdGVTZW5kVHJhbnNhY3Rpb25UeXBlID0gZnVuY3Rpb24odHJhbnNhY3Rpb25UeXBlKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uVHlwZSA9PT0gXCJub3JtYWxcIiAvKiBub3JtYWwgKi8gKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zYWN0aW9uVHlwZSA9PT0gXCJwZWdpblwiIC8qIHBlZ2luICovICkge1xuICAgICAgICAgICAgc3RhdHVzID0gbmV0d29ya1N0YXRlLm5ldHdvcmtUeXBlID09PSBcImJpdGNvaW5cIiAvKiBiaXRjb2luICovIDtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2FjdGlvblR5cGUgPT09IFwicGVnb3V0XCIgLyogcGVnb3V0ICovICkge1xuICAgICAgICAgICAgc3RhdHVzID0gbmV0d29ya1N0YXRlLm5ldHdvcmtUeXBlID09PSBcInNpZGVjaGFpblwiIC8qIHNpZGVjaGFpbiAqLyA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9O1xuICAgIHZhciBjcmVhdGVhc3NldCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy50cmFuc2FjdGlvblR5cGUpIHJldHVybiBoYW5kbGVFcnJvclJlc3BvbnNlKEVSUk9SX01FU1NBR0VTLnRyYW5zYWN0aW9uVHlwZVJlcXVpcmVkKTtcbiAgICAgICAgaWYgKCFwYXJhbXMubmFtZSkgcmV0dXJuIGhhbmRsZUVycm9yUmVzcG9uc2UoRVJST1JfTUVTU0FHRVMubmFtZVJlcXVpcmVkKTtcbiAgICAgICAgaWYgKCFwYXJhbXMuc3ltYm9sKSByZXR1cm4gaGFuZGxlRXJyb3JSZXNwb25zZShFUlJPUl9NRVNTQUdFUy5zeW1ib2xSZXF1aXJlZCk7XG4gICAgICAgIGlmICghcGFyYW1zLmltYWdlVXJsKSByZXR1cm4gaGFuZGxlRXJyb3JSZXNwb25zZShFUlJPUl9NRVNTQUdFUy5pbWFnZVVybFJlcXVpcmVkKTtcbiAgICAgICAgaWYgKCFwYXJhbXMuc3VwcGx5KSByZXR1cm4gaGFuZGxlRXJyb3JSZXNwb25zZShFUlJPUl9NRVNTQUdFUy5zdXBwbHlSZXF1aXJlZCk7XG4gICAgICAgIGlmIChwYXJhbXMuYXNzZXRUeXBlID09PSB2b2lkIDAgfHwgcGFyYW1zLmFzc2V0VHlwZSA9PT0gbnVsbCkgcmV0dXJuIGhhbmRsZUVycm9yUmVzcG9uc2UoRVJST1JfTUVTU0FHRVMuYXNzZXRUeXBlUmVxdWlyZWQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50cmFuc2FjdGlvblR5cGUgJiYgY2hlY2tXYWxsZXRDb25uZWN0aW9uKHJlc29sdmUsIHBhcmFtcy50cmFuc2FjdGlvblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KHdhbGxldFVSTCwgXCI/cmVxdWVzdFR5cGU9XCIsIFwiY3JlYXRlLWFzc2V0XCIgLyogY3JlYXRlQXNzZXQgKi8gKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRXaW5kb3cyID0gb3BlbldhbGxldFdpbmRvdyh1cmwpO1xuICAgICAgICAgICAgICAgIHNldFJlcXVlc3RUeXBlKFwiY3JlYXRlLWFzc2V0XCIgLyogY3JlYXRlQXNzZXQgKi8gKTtcbiAgICAgICAgICAgICAgICBzZXRDaGlsZFdpbmRvdyhjaGlsZFdpbmRvdzIpO1xuICAgICAgICAgICAgICAgIHNldENyZWF0ZUFzc2V0RGF0YShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgdHJhbnNmZXJhc3NldCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy5hc3NldElkKSByZXR1cm4gaGFuZGxlRXJyb3JSZXNwb25zZShFUlJPUl9NRVNTQUdFUy5hc3NldElkUmVxdWlyZWQpO1xuICAgICAgICBpZiAoIXBhcmFtcy5yZWNlaXZlckFkZHJlc3MpIHJldHVybiBoYW5kbGVFcnJvclJlc3BvbnNlKEVSUk9SX01FU1NBR0VTLnJlY2VpdmVyQWRkcmVzc1JlcXVpcmVkKTtcbiAgICAgICAgaWYgKCFwYXJhbXMuc3VwcGx5KSByZXR1cm4gaGFuZGxlRXJyb3JSZXNwb25zZShFUlJPUl9NRVNTQUdFUy5zdXBwbHlSZXF1aXJlZCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tXYWxsZXRDb25uZWN0aW9uKHJlc29sdmUsIFwidHJhbnNmZXJcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQod2FsbGV0VVJMLCBcIj9yZXF1ZXN0VHlwZT1cIiwgXCJ0cmFuc2Zlci1hc3NldFwiIC8qIHRyYW5zZmVyQXNzZXQgKi8gKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRXaW5kb3cyID0gb3BlbldhbGxldFdpbmRvdyh1cmwpO1xuICAgICAgICAgICAgICAgIHNldFJlcXVlc3RUeXBlKFwidHJhbnNmZXItYXNzZXRcIiAvKiB0cmFuc2ZlckFzc2V0ICovICk7XG4gICAgICAgICAgICAgICAgc2V0Q2hpbGRXaW5kb3coY2hpbGRXaW5kb3cyKTtcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2ZlckFzc2V0RGF0YShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfanN4X3J1bnRpbWUuanN4KSh1c2VDb25uZWN0b3IuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHdhbGxldFN0YXRlOiB3YWxsZXRTdGF0ZSxcbiAgICAgICAgICAgIG5ldHdvcmtTdGF0ZTogbmV0d29ya1N0YXRlLFxuICAgICAgICAgICAgY29ubmVjdDogY29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IGRpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzZW5kOiBzZW5kLFxuICAgICAgICAgICAgY3JlYXRlYXNzZXQ6IGNyZWF0ZWFzc2V0LFxuICAgICAgICAgICAgdHJhbnNmZXJhc3NldDogdHJhbnNmZXJhc3NldFxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBVc2VDb25uZWN0b3JQcm92aWRlcjogVXNlQ29ubmVjdG9yUHJvdmlkZXIsXG4gICAgdXNlQ29ubmVjdG9yOiB1c2VDb25uZWN0b3Jcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/anduro-wallet-connector/dist/index.js\n");

/***/ })

};
;